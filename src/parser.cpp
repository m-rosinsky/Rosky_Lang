
/******************************************************************************/
//
//  Source Name:                parser.cpp
//
//  Description:                This file is responsible for parsing a
//                              token table that is generated by the
//                              lexer. Parsing decisions are made
//                              in the main 'parse' function and subsequent
//                              parsing is handled in specific parse functions
//                              pertaining to the tokens needing to be parsed.
// 
//                              The parser will catch logical as well as
//                              syntactical errors.
//
//  Dependencies:               lexer_utils.hpp
//                              parser_utils.hpp
//                              error_handler.hpp
//                              evaluator.hpp
//                              variable_handler.hpp
//                              rosky_interface.hpp
//
//  Classes:                    None
//
//  Inherited Subprograms:      None
//
//  Exported Subprograms:       parse
//                              parse_expr
//                              
/******************************************************************************/

#include "../includes/parser.hpp"

/******************************************************************************/

void parse(const std::deque<std::shared_ptr<Token_T>>& __tokens,
           size_t __start_idx, size_t __end_idx) {

    // Create an index iterator. The reason this is
    // chosen over a traditional std::iterator is
    // because it may potentially go past the .end() point
    // and memory leak. The index can be checked against the max
    // size.
    size_t idx = __start_idx;

    // Check if the default was provided for the end index.
    __end_idx = __end_idx == 0 ? __tokens.size() : __end_idx;

    // Iterate through the token table.
    for (; idx < __end_idx; idx++) {

        // Token is a keyword.
        if (__tokens[idx]->_type == TOKEN_KW) {

            std::cout << "Keyword" << std::endl;
            continue;

        }

        // Token is a symbol.
        if (__tokens[idx]->_type == TOKEN_SYMBOL) {

            // Check if the token is a function.

            // Token must be an expression.
            size_t end_idx = find_nextof(__tokens, idx, ";");
            if (end_idx == 0) {
                throw_error(ERR_UNEXP_EOF, "", __tokens[idx]->_colnum, __tokens[idx]->_linenum);
            }
            auto ignore = parse_expr(__tokens, idx, end_idx);
            continue;

        }

        // Token is an operator.
        if (__tokens[idx]->_type == TOKEN_OP_BIN) {

            // Only select prefix ops can be considered starters
            // of an expression, otherwise this check fails.
            if (is_expr_op(__tokens[idx]->_token)) {
                size_t end_idx = find_nextof(__tokens, idx, ";");
                if (end_idx == 0) {
                    throw_error(ERR_UNEXP_EOF, "", __tokens[idx]->_colnum, __tokens[idx]->_linenum);
                }
                auto ignore = parse_expr(__tokens, idx, end_idx);
                continue;
            }

        }

        // Token is a control structure.
        if (__tokens[idx]->_type == TOKEN_CTRL) {

            // If left paren, parse as expression.
            if (__tokens[idx]->_token == "(") {
                size_t end_idx = find_nextof(__tokens, idx, ";");
                if (end_idx == 0) {
                    throw_error(ERR_UNEXP_EOF, "", __tokens[idx]->_colnum, __tokens[idx]->_linenum);
                }
                auto ignore = parse_expr(__tokens, idx, end_idx);
                continue;
            }

        }

        // Anything reaching here is considered a syntax error.
        throw_error(ERR_SYNTAX, __tokens[idx]->_token, __tokens[idx]->_colnum, __tokens[idx]->_linenum);

    }

}

/******************************************************************************/
