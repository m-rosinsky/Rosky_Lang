
/******************************************************************************/
//
//  Source Name:                parser.cpp
//
//  Description:                This file is responsible for parsing a
//                              token table that is generated by the
//                              lexer. Parsing decisions are made
//                              in the main 'parse' function and subsequent
//                              parsing is handled in specific parse functions
//                              pertaining to the tokens needing to be parsed.
// 
//                              The parser will catch logical as well as
//                              syntactical errors.
//
//  Dependencies:               lexer_utils.hpp
//                              error_handler.hpp
//
//  Classes:                    None
//
//  Inherited Subprograms:      None
//
//  Exported Subprograms:       parse
//                              
/******************************************************************************/

#include "../includes/parser.hpp"

/******************************************************************************/

void parse(const std::deque<std::shared_ptr<Token_T>>& __tokens) {

    // Create an index iterator. The reason this is
    // chosen over a traditional std::iterator is
    // because it may potentially go past the .end() point
    // and memory leak. The index can be checked against the max
    // size.
    size_t idx = 0;

    // Iterate through the token table.
    for (; idx < __tokens.size(); idx++) {

        // Token is a keyword.
        if (__tokens[idx]->_type == TOKEN_KW) {

            std::cout << "Keyword" << std::endl;
            continue;

        }

        // Token is a symbol.
        if (__tokens[idx]->_type == TOKEN_SYMBOL) {

            // Check if the token is a function.

            // Token must be an expression.
            auto ignore = parse_expr(__tokens, idx);
            continue;

        }

        // Token is an operator.
        if (__tokens[idx]->_type == TOKEN_OP_DLR) {

            // Only select prefix ops can be considered starters
            // of an expression, otherwise this check fails.
            if (is_expr_op(__tokens[idx]->_token)) {
                auto ignore = parse_expr(__tokens, idx);
                continue;
            }

        }

        // Anything reaching here is considered a syntax error.
        throw_error(ERR_SYNTAX, __tokens[idx]->_token, __tokens[idx]->_colnum, __tokens[idx]->_linenum);

    }

}

/******************************************************************************/
