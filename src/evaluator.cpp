
/******************************************************************************/
//
//  Source Name:                evaluator.cpp
//
//  Description:                This file is responsible for evaluating
//                              a parse tree generated by the parser and
//                              returning the resulting object.
//
//  Dependencies:               parser_utils.hpp
//                              lexer_utils.hpp
//                              error_handler.hpp
//                              variable_handler.hpp
//                              rosky_interface.hpp
//
//  Classes:                    None
//
//  Inherited Subprograms:      None
//
//  Exported Subprograms:       evaluate
//                              
/******************************************************************************/

#include "../includes/evaluator.hpp"

/******************************************************************************/

std::shared_ptr<RoskyInterface> evaluate(const std::shared_ptr<ParseNode>& __root,
                                         VariableTable_T& __var_table, bool __top) {

    // Operands
    
    if (__root->_type == PARSE_OPERAND) {

        // If this is a top level evaluation and the root is nullptr,
        // this means there was an unrecognized symbol.
        if (__root->_obj == nullptr && __top) {
            throw_error(ERR_UNREC_SYM, __root->_op, __root->_colnum, __root->_linenum);
        }
        return __root->_obj;
    }

    // Operators

    // Double left-right associative operators.
    if (__root->_type == PARSE_OPERATOR) {

        // Create a temp storage for the return value and the left and right operands.
        std::shared_ptr<RoskyInterface> ret_obj = nullptr;

        std::shared_ptr<RoskyInterface> left = evaluate(__root->_left, __var_table, false);
        std::shared_ptr<RoskyInterface> right = evaluate(__root->_right, __var_table, false);

        // The right side of an op is never allowed to be nullptr. This means
        // a symbol was unrecognized. Throw an error.
        if (right == nullptr) {
            throw_error(ERR_UNREC_SYM, __root->_right->_op, __root->_right->_colnum, __root->_right->_linenum);
        }

        // The left side of the op is allowed to be nullptr on assignments,
        // so check those first.
        if (is_assignment_op(__root->_op)) {

            // Simple Assignment.
            if (__root->_op == "=") {
                __var_table.set_entry(__root->_left->_op, right);
            }

            // std::cout << get_entry(__root->_left->_op)->to_string() << std::endl;

            // ***DEBUG***
            std::cout << __root->_left->_op << " = " << right->to_string() << std::endl;
            // ***DEBUG***

            // Return the right-side object.
            return right;

        }

        // Now if the left side of the op is a nullptr, throw an error.
        if ((!is_assignment_op(__root->_op)) && left == nullptr) {
            throw_error(ERR_UNREC_SYM, __root->_left->_op, __root->_left->_colnum, __root->_left->_linenum);
        }

        if (__root->_op == "+") {
            ret_obj = left->add_op(right);
        }
        if (__root->_op == "*") {
            ret_obj = left->mul_op(right);
        }

        // If the ret_obj is nullptr, the operator was incompat.
        if (ret_obj == nullptr) {

            // Construct the error message.
            std::string err_msg = "'" + __root->_op + "' with types: '";
            err_msg += left->get_type_string() + "' and '";
            err_msg += right->get_type_string() + "'";
            throw_error(ERR_OP_INCOMPAT, err_msg, __root->_colnum, __root->_linenum);
        }

        // std::cout << ret_obj->to_string() << std::endl;

        // Return the object.
        return ret_obj;

    }

    // Should never reach here, but for safety.
    throw_error(ERR_UNEXP_OP, __root->_op, __root->_colnum, __root->_linenum);
    return nullptr;

}

/******************************************************************************/
